# 262-create-noisecan-for-sim2real-controls
### signature:
- status: wait
- issue: 262
- source: github
- url: https://github.com/timcash/dialtone/issues/262
- synced-at: 2026-02-21T19:50:23Z
### sync:
- github-updated-at: 2026-02-14T21:05:57Z
- last-pulled-at: 2026-02-21T19:50:23Z
- last-pushed-at: 
- github-labels-hash: 
### description:
- Sim-to-Real of locomotion policies is traditionally framed as a physics gap in robotics. The industry responds with better contact models, friction cones, more domain randomization, etc. We benchmark simulators like Isaac Sim (PhysX) and MJX against each other (Sim2Sim) to make sure the math agrees.
- Yet robots still fail in real life, in non-obvious ways. 
- Not because friction was 3% off, but because a CAN packet arrived late, a thread missed its deadline, or an IMU integration drifted just enough to destabilize the controller. 
- Reality is noisy, late, and unfair. So how do we optimize for real world uncertainty?
- In our latest work on Asimov Legs, bridged Sim2Real locomotion further by running our real robot firmware and control stack inside a deliberately imperfect simulated environment.
- In this post, we share the methodology and results. We are optimistic about what it implies for hardware-software-AI co-design in modern robotics.
- Don't just simulate the robot, simulate the embedded environment
- The core idea is to make the processor part of the robot dynamics in training. 
- We call this Processor-in-the-Loop because the control loop closes through the actual firmware execution model. We account for its threads, timing, and numeric constraints. This makes the processor itself part of the robot’s dynamics during training.
- ![image](https://github.com/user-attachments/assets/b7d52429-46ca-45a4-9682-956eb7269414)
- How it works:
- Sensor Fidelity: We don't cheat. We don't pass “truth” orientation to the controller. We stream raw accelerometer and gyro data from the MuJoCo lsm6dsox model over our I2C Emulator. This mimics the exact register-level behavior of the sensor bus.
- The Fusion Stack: The firmware runs the open-source xioTechnologies/Fusion C library to calculate projected gravity ($g_z$) in real-time. This is critical because Python math (infinite precision) and Embedded C math (constrained floats) often disagree. If our integration of the Fusion library drifts, or if the thread priority causes a bottleneck, the robot falls in real life.
- Binary Confidence: We aren't running a simplified “simulation version” of our code. The firmware talks to our CANBus Emulator exactly as it would talk to the physical CAN hardware. It doesn't know its in a simulation.
- The implication of this pipeline is that we catch bugs in the pull request, not when the robot is standing up.
- ![image](https://github.com/user-attachments/assets/610ce9c4-f629-4f65-bbb1-518eb2d82589)
### tags:
- todo
### comments-github:
- none
### comments-outbound:
- TODO: add a bullet comment here to post to GitHub
### task-dependencies:
### documentation:
### test-condition-1:
- TODO
### test-command:
- TODO
### reviewed:
### tested:
### last-error-types:
### last-error-times:
### log-stream-command:
- TODO
### last-error-loglines:
### notes:
- title: create noiseCAN for sim2real controls
- state: OPEN
- author: timcash
- created-at: 2026-02-14T21:05:57Z
- updated-at: 2026-02-14T21:05:57Z
